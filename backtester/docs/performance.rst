Профилирование и производительность
===================================

Этот модульный бэктестер рассчитан на работу с достаточно длинными
историческими рядами, поэтому важно понимать, где тратится время исполнения
и как можно ускорить код.

Запуск профилирования
---------------------

Для профилирования предусмотрен отдельный модуль
``backtester.profile_backtest``, который использует стандартный модуль
:mod:`cProfile`.

Пример запуска:

.. code-block:: bash

   python -m backtester.profile_backtest \
     --csv backtester/data/AAPL_5Y.csv \
     --strategy ma \
     --fast 5 --slow 10 \
     --cash 10000 \
     --commission 0.0 \
     --mode on_close \
     --lot 1.0 \
     --sort cumulative \
     --lines 30

После выполнения вы увидите:

* блок с ключевыми метриками бэктеста (start_equity, end_equity и т.п.);
* сводную таблицу профилирования с самыми «тяжёлыми» функциями.

Параметры ``--sort`` и ``--lines`` управляют форматом вывода:

* ``--sort time`` — сортировка по времени в одной функции;
* ``--sort cumulative`` — сортировка по совокупному времени (включая вызовы);
* ``--lines N`` — вывести не более N строк отчёта.

Интерпретация результатов
-------------------------

В типичном запуске основное время будет тратиться в следующих частях:

* ``Engine.run`` — главный цикл по барам;
* методах стратегий (например, ``MovingAverageCross.on_bar`` или
  ``DonchianBreakout.on_bar``), где происходит расчёт индикаторов;
* методе ``Broker.execute``, который обрабатывает сделки и комиссии.

Если в отчёте профилировщика:

* функции стратегий занимают заметную часть времени, это ожидаемо —
  на каждом баре выполняются расчёты индикаторов;
* ``Broker.execute`` и сопутствующие методы занимают слишком много времени,
  это может указывать на избыточное количество сделок или неэффективные
  операции с числами.

Идеи для оптимизации
--------------------

На основе профилирования можно предложить несколько направлений улучшения:

1. Оптимизация расчётов в стратегиях:

   * вместо пересчёта индикаторов «с нуля» можно хранить вспомогательные
     скользящие суммы и обновлять их инкрементально;
   * при расширении набора индикаторов — вынести общие расчёты в отдельные
     функции или классы с переиспользованием.

2. Работа с данными:

   * при переходе к гораздо большим объёмам данных возможно использование
     векторизованных библиотек (например, NumPy) для ускорения расчётов
     индикаторов;
   * при необходимости многократных прогонов на одних и тех же данных
     DataFeed можно переиспользовать между запусками.

3. Архитектурные улучшения:

   * анализаторы (например, :class:`backtester.core.analyzers.DrawdownAnalyzer`)
     не должны выполнять тяжёлые операции на каждом баре; текущая реализация
     опирается на простые арифметические действия и хорошо масштабируется;
   * при появлении новых анализаторов разумно следить за тем, чтобы их
     логика оставалась ``O(1)`` на бар.

Для учебных объёмов данных текущая реализация бэктестера работает достаточно
быстро. Профилирование в первую очередь служит демонстрацией того, как
анализировать производительность и где искать узкие места по мере роста
проекта.
